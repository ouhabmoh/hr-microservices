you are an expert senior software enginerr in backend engineering, nodejs, expressjs and typescript, i will give you, the code for my application hr recruitment platform backend api, and i need you to write tests for it using jest, and i need you to write all type of tests testing everything in the code following testing best practices, we will start with routes for jobs  : 'import express from 'express'; import auth from '../../middlewares/auth'; import validate from '../../middlewares/validate'; import { jobValidation } from '../../validations'; import { jobController, applicationController } from '../../controllers'; import upload from '../../middlewares/upload';  const router = express.Router();  // Job routes router   .route('/')   .post(auth('manageJobs'), validate(jobValidation.createJob), jobController.createJob)   .get(auth('getJobs'), validate(jobValidation.getJobs), jobController.getJobs);  router   .route('/:jobId')   .get(auth('getJobs'), validate(jobValidation.getJob), jobController.getJob)   .patch(auth('manageJobs'), validate(jobValidation.updateJob), jobController.updateJob);  // Application routes router   .route('/:jobId/applications')   .post(     auth('applyJob'),     upload.single('resume'),     validate(jobValidation.applyJob),     applicationController.applyJob   )   .get(     auth('getApplications'),     validate(jobValidation.getApplications),     applicationController.getApplications   );  router   .route('/:jobId/applications/:applicationId')   .get(     auth('getApplication'),     validate(jobValidation.getApplication),     applicationController.getApplication   )   .patch(     auth('reviewApplication'),     validate(jobValidation.reviewApplication),     applicationController.reviewApplication   );  export default router; ', then controller : 'import httpStatus from 'http-status'; import pick from '../utils/pick'; import ApiError from '../utils/ApiError'; import catchAsync from '../utils/catchAsync'; import { jobService } from '../services'; import { User } from '@prisma/client';  // Job controllers const createJob = catchAsync(async (req, res) => {   const job = await jobService.createJob(req.body, req.user);   res.status(httpStatus.CREATED).send(job); });  const getJobs = catchAsync(async (req, res) => {   const user = req.user as User;   const filter = pick(req.query, ['title', 'location', 'employmentType']);   const options = pick(req.query, ['sortBy', 'limit', 'page']);    const result = await jobService.queryJobs(filter, user.role, options);   res.send(result); });  const getJob = catchAsync(async (req, res) => {   const job = await jobService.getJobById(req.params.jobId);   if (!job) {     throw new ApiError(httpStatus.NOT_FOUND, 'Job not found');   }   res.send(job); });  const updateJob = catchAsync(async (req, res) => {   const job = await jobService.updateJobById(req.params.jobId, req.body, req.user);   res.send(job); });  export default {   createJob,   getJobs,   getJob,   updateJob }; '

auth middleware : 'import passport from 'passport'; import httpStatus from 'http-status'; import ApiError from '../utils/ApiError'; import { roleRights } from '../config/roles'; import { NextFunction, Request, Response } from 'express'; import { User } from '@prisma/client';  const verifyCallback =   (     req: any,     resolve: (value?: unknown) => void,     reject: (reason?: unknown) => void,     requiredRights: string[]   ) =>   async (err: unknown, user: User | false, info: unknown) => {     if (err || info || !user) {       return reject(new ApiError(httpStatus.UNAUTHORIZED, 'Please authenticate'));     }     req.user = user;      if (requiredRights.length) {       const userRights = roleRights.get(user.role) ?? [];        const hasRequiredRights = requiredRights.every((requiredRight) =>         userRights.includes(requiredRight)       );       if (!hasRequiredRights && req.params.userId !== user.id) {         return reject(new ApiError(httpStatus.FORBIDDEN, 'Forbidden'));       }     }      resolve();   };  const auth =   (...requiredRights: string[]) =>   async (req: Request, res: Response, next: NextFunction) => {     return new Promise((resolve, reject) => {       passport.authenticate(         'jwt',         { session: false },         verifyCallback(req, resolve, reject, requiredRights)       )(req, res, next);     })       .then(() => next())       .catch((err) => next(err));   };  export default auth; ', job service : 'import { Job, Role } from '@prisma/client'; import httpStatus from 'http-status'; import prisma from '../client'; import ApiError from '../utils/ApiError';  // Job service const createJob = async (jobBody: any, currentUser: any): Promise<Job> => {   return prisma.job.create({     data: {       ...jobBody,       recruiterId: currentUser.id     }   }); };  const queryJobs = async <Key extends keyof Job>(   filter: object,   userRole: Role,   options: {     limit?: number;     page?: number;     sortBy?: string;     sortType?: 'asc' | 'desc';   },   keys: Key[] = [     'id',     'title',     'description',     'location',     'employmentType',     'isClosed',     'deadline',     'createdAt',     'updatedAt'   ] as Key[] ): Promise<Pick<Job, Key>[]> => {   const page = options.page ?? 1;   const limit = options.limit ?? 10;   const sortBy = options.sortBy;   const sortType = options.sortType ?? 'desc';   if(userRole === Role.CANDIDATE){     filter = {...filter, isClosed: false,  deadline: {       gt: new Date() // Filter for jobs with deadline greater than current date     }};   }   const jobs = await prisma.job.findMany({     where: {       ...filter                  },     select: keys.reduce((obj, k) => ({ ...obj, [k]: true }), {}),     skip: (page - 1) * limit,     take: limit,     orderBy: sortBy ? { [sortBy]: sortType } : undefined   });   return jobs as Pick<Job, Key>[]; };  const getJobById = async <Key extends keyof Job>(   id: number,   keys: Key[] = [     'id',     'title',     'description',     'location',     'employmentType',     'deadline',     'createdAt',     'updatedAt'   ] as Key[] ): Promise<Pick<Job, Key> | null> => {   return prisma.job.findUnique({     where: { id },     select: keys.reduce((obj, k) => ({ ...obj, [k]: true }), {})   }) as Promise<Pick<Job, Key> | null>; };  const updateJobById = async <Key extends keyof Job>(   jobId: number,   updateBody: any,   currentUser: any,   keys: Key[] = [     'id',     'title',     'description',     'location',     'isClosed',     'employmentType',     'deadline',     'updatedAt'   ] as Key[] ): Promise<Pick<Job, Key> | null> => {   const job = await getJobById(jobId, ['id', 'recruiterId']);   if (!job) {     throw new ApiError(httpStatus.NOT_FOUND, 'Job not found');   }   if (job.recruiterId !== currentUser.id) {     throw new ApiError(httpStatus.FORBIDDEN, 'You are not authorized to update this job');   }   const updatedJob = await prisma.job.update({     where: { id: job.id },     data: updateBody,     select: keys.reduce((obj, k) => ({ ...obj, [k]: true }), {})   });   return updatedJob as Pick<Job, Key> | null; };  export default {   createJob,   queryJobs,   getJobById,   updateJobById }; ', job validation : 'import Joi from 'joi';  const createJob = {   body: Joi.object().keys({     title: Joi.string().required(),     description: Joi.string().required(),     location: Joi.string().required(),     employmentType: Joi.string()       .valid('full-time', 'part-time', 'contract', 'internship')       .required(),     deadline: Joi.date().greater(new Date()).required()   }) };  const getJobs = {   query: Joi.object().keys({     title: Joi.string(),     location: Joi.string(),     employmentType: Joi.string().valid('full-time', 'part-time', 'contract', 'internship'),     sortBy: Joi.string(),     limit: Joi.number().integer(),     page: Joi.number().integer()   }) };  const getJob = {   params: Joi.object().keys({     jobId: Joi.number().integer().required()   }) };  const updateJob = {   params: Joi.object().keys({     jobId: Joi.number().integer().required()   }),   body: Joi.object().keys({     title: Joi.string(),     description: Joi.string(),     location: Joi.string(),     employmentType: Joi.string().valid('full-time', 'part-time', 'contract', 'internship'),     isClosed: Joi.boolean(),     deadline: Joi.date().greater(new Date())   }) };  const deleteJob = {   params: Joi.object().keys({     jobId: Joi.number().integer().required()   }) };  const applyJob = {   params: Joi.object().keys({     jobId: Joi.number().integer().required()   }),   body: Joi.object().keys({     coverletter: Joi.string()   }) };  const getApplications = {   params: Joi.object().keys({     jobId: Joi.number().integer().required()   }),   query: Joi.object().keys({     status: Joi.string().valid('pending', 'accepted', 'rejected'),     sortBy: Joi.string(),     limit: Joi.number().integer(),     page: Joi.number().integer()   }) };  const getApplication = {   params: Joi.object().keys({     jobId: Joi.number().integer().required(),     applicationId: Joi.number().integer().required()   }) };  const reviewApplication = {   params: Joi.object().keys({     jobId: Joi.number().integer().required(),     applicationId: Joi.number().integer().required()   }),   body: Joi.object().keys({     status: Joi.string().valid('pending', 'accepted', 'rejected').required(),     evaluation: Joi.number()   }) };  export default {   createJob,   getJobs,   getJob,   updateJob,   deleteJob,   applyJob,   getApplications,   getApplication,   reviewApplication }; ', prisma schema : '// This is your Prisma schema file, // learn more about it in the docs: https://pris.ly/d/prisma-schema  generator client {   provider = "prisma-client-js" }  datasource db {   provider = "postgresql"   url      = env("DATABASE_URL") }  model User {   id        Int    @id @default(autoincrement())   firstName String   lastName  String   email     String @unique   username  String @unique    password        String   role            Role     @default(CANDIDATE)   isEmailVerified Boolean  @default(false)   createdAt       DateTime @default(now())   updatedAt       DateTime @updatedAt   deletedAt        DateTime?   // Field to indicate soft deletion   Token           Token[]    resumes     Resume[]   jobs        Job[]   Application Application[] }  model Job {   id             Int           @id @default(autoincrement())   title          String   description    String   location       String   employmentType String   deadline       DateTime   isClosed         Boolean    @default(false) // New field to indicate if the job is closed    createdAt      DateTime      @default(now())   updatedAt      DateTime      @updatedAt   recruiter      User          @relation(fields: [recruiterId], references: [id])   recruiterId    Int   applications   Application[] }  model Application {   id          Int      @id @default(autoincrement())   job         Job      @relation(fields: [jobId], references: [id])   jobId       Int   candidate   User     @relation(fields: [candidateId], references: [id], onDelete: Cascade)   candidateId Int   resume      Resume   @relation(fields: [resumeId], references: [id])   resumeId    Int      @unique   status      String   evaluation  Int?   createdAt   DateTime @default(now())   updatedAt   DateTime @updatedAt }  model Resume {   id          Int          @id @default(autoincrement())   candidate   User         @relation(fields: [candidateId], references: [id] , onDelete: Cascade)   candidateId Int   filename    String   application Application?   createdAt   DateTime     @default(now())   updatedAt   DateTime     @updatedAt }  model Token {   id          Int       @id @default(autoincrement())   token       String   type        TokenType   expires     DateTime   blacklisted Boolean   createdAt   DateTime  @default(now())   user        User      @relation(fields: [userId], references: [id])   userId      Int }  enum Role {   CANDIDATE   RECRUITER   ADMIN }  enum TokenType {   ACCESS   REFRESH   RESET_PASSWORD   VERIFY_EMAIL } '