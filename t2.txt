you are an expert senior software engineer in backend engineering, api, nodejs, typescript and expressjs and microservices i have a monolith backend for an hr recruitment platform that have users(admins, candidates and recruiters) , jobs, applications and resumes, i want to refactor this monolith app to microservices, i will provide with the code of it and you rewrite it in microservices following best practices and use docker and docker compose to run the microservices : 'import { Server } from 'http'; import app from './app'; import prisma from './client'; import config from './config/config'; import logger from './config/logger';  let server: Server; prisma.$connect().then(() => {   logger.info('Connected to SQL Database');   server = app.listen(config.port, () => {     logger.info(`Listening to port ${config.port}`);   }); });  const exitHandler = () => {   if (server) {     server.close(() => {       logger.info('Server closed');       process.exit(1);     });   } else {     process.exit(1);   } };  const unexpectedErrorHandler = (error: unknown) => {   logger.error(error);   exitHandler(); };  process.on('uncaughtException', unexpectedErrorHandler); process.on('unhandledRejection', unexpectedErrorHandler);  process.on('SIGTERM', () => {   logger.info('SIGTERM received');   if (server) {     server.close();   } }); ',  'import { PrismaClient } from '@prisma/client'; import config from './config/config';  // add prisma to the NodeJS global type interface CustomNodeJsGlobal extends Global {   prisma: PrismaClient; }  // Prevent multiple instances of Prisma Client in development declare const global: CustomNodeJsGlobal;  const prisma = global.prisma || new PrismaClient();  if (config.env === 'development') global.prisma = prisma;  export default prisma; ', "import express from 'express'; import helmet from 'helmet'; import compression from 'compression'; import cors from 'cors'; import passport from 'passport'; import httpStatus from 'http-status'; import config from './config/config'; import morgan from './config/morgan'; import xss from './middlewares/xss'; import { jwtStrategy } from './config/passport'; import { authLimiter } from './middlewares/rateLimiter'; import routes from './routes/v1'; import { errorConverter, errorHandler } from './middlewares/error'; import ApiError from './utils/ApiError';  const app = express();  if (config.env !== 'test') {   app.use(morgan.successHandler);   app.use(morgan.errorHandler); }  // set security HTTP headers app.use(helmet());  // parse json request body app.use(express.json());  // parse urlencoded request body app.use(express.urlencoded({ extended: true }));  // sanitize request data app.use(xss());  // gzip compression app.use(compression());  // enable cors app.use(cors()); app.options('*', cors());  // jwt authentication app.use(passport.initialize()); passport.use('jwt', jwtStrategy);  // limit repeated failed requests to auth endpoints if (config.env === 'production') {   app.use('/v1/auth', authLimiter); }  // v1 api routes app.use('/v1', routes);  // send back a 404 error for any unknown api request app.use((req, res, next) => {   next(new ApiError(httpStatus.NOT_FOUND, 'Not found')); });  // convert error to ApiError, if needed app.use(errorConverter);  // handle error app.use(errorHandler);  export default app; ", 

'import express from 'express'; import authRoute from './auth.route'; import userRoute from './user.route'; import jobRoute from './job.route'; import applicationRoute from './application.route'; import docsRoute from './docs.route'; import config from '../../config/config';  const router = express.Router();  const defaultRoutes = [   {     path: '/auth',     route: authRoute   },   {     path: '/users',     route: userRoute   },   {     path: '/jobs',     route: jobRoute   },   {     path: '/applications',     route: applicationRoute   } ];  const devRoutes = [   // routes available only in development mode   {     path: '/docs',     route: docsRoute   } ];  defaultRoutes.forEach((route) => {   router.use(route.path, route.route); });  /* istanbul ignore next */ if (config.env === 'development') {   devRoutes.forEach((route) => {     router.use(route.path, route.route);   }); }  export default router; ', '', '',  'import express from 'express'; import auth from '../../middlewares/auth'; import validate from '../../middlewares/validate'; import { jobValidation } from '../../validations'; import { jobController, applicationController } from '../../controllers'; import upload from '../../middlewares/upload';  const router = express.Router();  // Job routes router   .route('/')   .post(auth('manageJobs'), validate(jobValidation.createJob), jobController.createJob)   .get(auth('getJobs'), validate(jobValidation.getJobs), jobController.getJobs);  router   .route('/:jobId')   .get(auth('getJobs'), validate(jobValidation.getJob), jobController.getJob)   .patch(auth('manageJobs'), validate(jobValidation.updateJob), jobController.updateJob);  // Application routes router   .route('/:jobId/applications')   .post(     auth('applyJob'),     upload.single('resume'),     validate(jobValidation.applyJob),     applicationController.applyJob   )   .get(     auth('getApplications'),     validate(jobValidation.getApplications),     applicationController.getApplications   );  router   .route('/:jobId/applications/:applicationId')   .get(     auth('getApplication'),     validate(jobValidation.getApplication),     applicationController.getApplication   )   .patch(     auth('reviewApplication'),     validate(jobValidation.reviewApplication),     applicationController.reviewApplication   );  export default router; ', 'import httpStatus from 'http-status'; import catchAsync from '../utils/catchAsync'; import { authService, userService, tokenService, emailService } from '../services'; import exclude from '../utils/exclude'; import { User } from '@prisma/client';  const register = catchAsync(async (req, res) => {   const { firstName, lastName, username, email, password, role } = req.body;   const user = await userService.createUser(firstName, lastName, username, email, password, role);   const userWithoutPassword = exclude(user, ['password', 'createdAt', 'updatedAt']);   const tokens = await tokenService.generateAuthTokens(user);   res.status(httpStatus.CREATED).send({ user: userWithoutPassword, tokens }); });  const login = catchAsync(async (req, res) => {   const { email, password } = req.body;   const user = await authService.loginUserWithEmailAndPassword(email, password);   const tokens = await tokenService.generateAuthTokens(user);   res.send({ user, tokens }); });  const logout = catchAsync(async (req, res) => {   await authService.logout(req.body.refreshToken);   res.status(httpStatus.NO_CONTENT).send(); });  const refreshTokens = catchAsync(async (req, res) => {   const tokens = await authService.refreshAuth(req.body.refreshToken);   res.send({ ...tokens }); });  const forgotPassword = catchAsync(async (req, res) => {   const resetPasswordToken = await tokenService.generateResetPasswordToken(req.body.email);   await emailService.sendResetPasswordEmail(req.body.email, resetPasswordToken);   res.status(httpStatus.NO_CONTENT).send(); });  const resetPassword = catchAsync(async (req, res) => {   await authService.resetPassword(req.query.token as string, req.body.password);   res.status(httpStatus.NO_CONTENT).send(); });  const sendVerificationEmail = catchAsync(async (req, res) => {   const user = req.user as User;   const verifyEmailToken = await tokenService.generateVerifyEmailToken(user);   await emailService.sendVerificationEmail(user.email, verifyEmailToken);   res.status(httpStatus.NO_CONTENT).send(); });  const verifyEmail = catchAsync(async (req, res) => {   await authService.verifyEmail(req.query.token as string);   res.status(httpStatus.NO_CONTENT).send(); });  export default {   register,   login,   logout,   refreshTokens,   forgotPassword,   resetPassword,   sendVerificationEmail,   verifyEmail }; ', 'import httpStatus from 'http-status'; import pick from '../utils/pick'; import ApiError from '../utils/ApiError'; import catchAsync from '../utils/catchAsync'; import { applicationService } from '../services';  const applyJob = catchAsync(async (req, res) => {   const application = await applicationService.applyJob(     req.params.jobId,     req.body,     req.file,     req.user   );   res.status(httpStatus.CREATED).send(application); });  const getApplications = catchAsync(async (req, res) => {   const filter = pick(req.query, ['status']);   const options = pick(req.query, ['sortBy', 'limit', 'page']);   const result = await applicationService.queryApplications(req.params.jobId, filter, options);   res.send(result); });  const getApplication = catchAsync(async (req, res) => {   const application = await applicationService.getApplicationById(     req.params.jobId,     req.params.applicationId   );   if (!application) {     throw new ApiError(httpStatus.NOT_FOUND, 'Application not found');   }   res.send(application); });  const reviewApplication = catchAsync(async (req, res) => {   const application = await applicationService.reviewApplication(     req.params.jobId,     req.params.applicationId,     req.body   );   res.send(application); });  export default {   applyJob,   getApplications,   getApplication,   reviewApplication }; ', 'import httpStatus from 'http-status'; import pick from '../utils/pick'; import ApiError from '../utils/ApiError'; import catchAsync from '../utils/catchAsync'; import { jobService } from '../services'; import { User } from '@prisma/client';  // Job controllers const createJob = catchAsync(async (req, res) => {   const job = await jobService.createJob(req.body, req.user);   res.status(httpStatus.CREATED).send(job); });  const getJobs = catchAsync(async (req, res) => {   const user = req.user as User;   const filter = pick(req.query, ['title', 'location', 'employmentType']);   const options = pick(req.query, ['sortBy', 'limit', 'page']);    const result = await jobService.queryJobs(filter, user.role, options);   res.send(result); });  const getJob = catchAsync(async (req, res) => {   const job = await jobService.getJobById(req.params.jobId);   if (!job) {     throw new ApiError(httpStatus.NOT_FOUND, 'Job not found');   }   res.send(job); });  const updateJob = catchAsync(async (req, res) => {   const job = await jobService.updateJobById(req.params.jobId, req.body, req.user);   res.send(job); });  export default {   createJob,   getJobs,   getJob,   updateJob }; ', 'import httpStatus from 'http-status'; import pick from '../utils/pick'; import ApiError from '../utils/ApiError'; import catchAsync from '../utils/catchAsync'; import { userService } from '../services';  const createUser = catchAsync(async (req, res) => {   const { firstName, lastName, email, password, username, role } = req.body;   const user = await userService.createUser(firstName, lastName, email, password, username, role);   res.status(httpStatus.CREATED).send(user); });  const getUsers = catchAsync(async (req, res) => {   const filter = pick(req.query, ['name', 'role']);   const options = pick(req.query, ['sortBy', 'limit', 'page']);   const result = await userService.queryUsers(filter, options);   res.send(result); });  const getUser = catchAsync(async (req, res) => {   const user = await userService.getUserById(req.params.userId);   if (!user) {     throw new ApiError(httpStatus.NOT_FOUND, 'User not found');   }   res.send(user); });  const updateUser = catchAsync(async (req, res) => {   const user = await userService.updateUserById(req.params.userId, req.body);   res.send(user); });  const deleteUser = catchAsync(async (req, res) => {   await userService.deleteUserById(req.params.userId);   res.status(httpStatus.NO_CONTENT).send(); });  export default {   createUser,   getUsers,   getUser,   updateUser,   deleteUser }; ', 'import passport from 'passport'; import httpStatus from 'http-status'; import ApiError from '../utils/ApiError'; import { roleRights } from '../config/roles'; import { NextFunction, Request, Response } from 'express'; import { User } from '@prisma/client';  const verifyCallback =   (     req: any,     resolve: (value?: unknown) => void,     reject: (reason?: unknown) => void,     requiredRights: string[]   ) =>   async (err: unknown, user: User | false, info: unknown) => {     if (err || info || !user) {       return reject(new ApiError(httpStatus.UNAUTHORIZED, 'Please authenticate'));     }     req.user = user;      if (requiredRights.length) {       const userRights = roleRights.get(user.role) ?? [];        const hasRequiredRights = requiredRights.every((requiredRight) =>         userRights.includes(requiredRight)       );       if (!hasRequiredRights && req.params.userId !== user.id) {         return reject(new ApiError(httpStatus.FORBIDDEN, 'Forbidden'));       }     }      resolve();   };  const auth =   (...requiredRights: string[]) =>   async (req: Request, res: Response, next: NextFunction) => {     return new Promise((resolve, reject) => {       passport.authenticate(         'jwt',         { session: false },         verifyCallback(req, resolve, reject, requiredRights)       )(req, res, next);     })       .then(() => next())       .catch((err) => next(err));   };  export default auth; ', '''import { ErrorRequestHandler } from 'express'; import { Prisma } from '@prisma/client'; import httpStatus from 'http-status'; import config from '../config/config'; import logger from '../config/logger'; import ApiError from '../utils/ApiError';  export const errorConverter: ErrorRequestHandler = (err, req, res, next) => {   let error = err;   if (!(error instanceof ApiError)) {     const statusCode =       error.statusCode || error instanceof Prisma.PrismaClientKnownRequestError         ? httpStatus.BAD_REQUEST         : httpStatus.INTERNAL_SERVER_ERROR;     const message = error.message || httpStatus[statusCode];     error = new ApiError(statusCode, message, false, err.stack);   }   next(error); };  // eslint-disable-next-line no-unused-vars, @typescript-eslint/no-unused-vars export const errorHandler: ErrorRequestHandler = (err, req, res, next) => {   let { statusCode, message } = err;   if (config.env === 'production' && !err.isOperational) {     statusCode = httpStatus.INTERNAL_SERVER_ERROR;     message = httpStatus[httpStatus.INTERNAL_SERVER_ERROR];   }    res.locals.errorMessage = err.message;    const response = {     code: statusCode,     message,     ...(config.env === 'development' && { stack: err.stack })   };    if (config.env === 'development') {     logger.error(err);   }    res.status(statusCode).send(response); }; ', 'import httpStatus from 'http-status'; import tokenService from './token.service'; import userService from './user.service'; import ApiError from '../utils/ApiError'; import { TokenType, User } from '@prisma/client'; import prisma from '../client'; import { encryptPassword, isPasswordMatch } from '../utils/encryption'; import { AuthTokensResponse } from '../types/response'; import exclude from '../utils/exclude';  /**  * Login with username and password  * @param {string} email  * @param {string} password  * @returns {Promise<Omit<User, 'password'>>}  */ const loginUserWithEmailAndPassword = async (   email: string,   password: string ): Promise<Omit<User, 'password'>> => {   const user = await userService.getUserByEmail(email, [     'id',     'firstName',     'lastName',     'email',     'username',     'password',     'role',     'isEmailVerified',     'createdAt',     'updatedAt',     'deletedAt'   ]);   if (!user || user.deletedAt || !(await isPasswordMatch(password, user.password as string))) {     throw new ApiError(httpStatus.UNAUTHORIZED, 'Incorrect email or password');   }   return exclude(user, ['password']); };  /**  * Logout  * @param {string} refreshToken  * @returns {Promise<void>}  */ const logout = async (refreshToken: string): Promise<void> => {   const refreshTokenData = await prisma.token.findFirst({     where: {       token: refreshToken,       type: TokenType.REFRESH,       blacklisted: false     }   });   if (!refreshTokenData) {     throw new ApiError(httpStatus.NOT_FOUND, 'Not found');   }   await prisma.token.delete({ where: { id: refreshTokenData.id } }); };  /**  * Refresh auth tokens  * @param {string} refreshToken  * @returns {Promise<AuthTokensResponse>}  */ const refreshAuth = async (refreshToken: string): Promise<AuthTokensResponse> => {   try {     const refreshTokenData = await tokenService.verifyToken(refreshToken, TokenType.REFRESH);     const { userId } = refreshTokenData;     await prisma.token.delete({ where: { id: refreshTokenData.id } });     return tokenService.generateAuthTokens({ id: userId });   } catch (error) {     throw new ApiError(httpStatus.UNAUTHORIZED, 'Please authenticate');   } };  /**  * Reset password  * @param {string} resetPasswordToken  * @param {string} newPassword  * @returns {Promise<void>}  */ const resetPassword = async (resetPasswordToken: string, newPassword: string): Promise<void> => {   try {     const resetPasswordTokenData = await tokenService.verifyToken(       resetPasswordToken,       TokenType.RESET_PASSWORD     );     const user = await userService.getUserById(resetPasswordTokenData.userId);     if (!user) {       throw new Error();     }     const encryptedPassword = await encryptPassword(newPassword);     await userService.updateUserById(user.id, { password: encryptedPassword });     await prisma.token.deleteMany({ where: { userId: user.id, type: TokenType.RESET_PASSWORD } });   } catch (error) {     throw new ApiError(httpStatus.UNAUTHORIZED, 'Password reset failed');   } };  /**  * Verify email  * @param {string} verifyEmailToken  * @returns {Promise<void>}  */ const verifyEmail = async (verifyEmailToken: string): Promise<void> => {   try {     const verifyEmailTokenData = await tokenService.verifyToken(       verifyEmailToken,       TokenType.VERIFY_EMAIL     );     await prisma.token.deleteMany({       where: { userId: verifyEmailTokenData.userId, type: TokenType.VERIFY_EMAIL }     });     await userService.updateUserById(verifyEmailTokenData.userId, { isEmailVerified: true });   } catch (error) {     throw new ApiError(httpStatus.UNAUTHORIZED, 'Email verification failed');   } };  export default {   loginUserWithEmailAndPassword,   isPasswordMatch,   encryptPassword,   logout,   refreshAuth,   resetPassword,   verifyEmail }; ',  , 'import { Job, Role } from '@prisma/client'; import httpStatus from 'http-status'; import prisma from '../client'; import ApiError from '../utils/ApiError';  // Job service const createJob = async (jobBody: any, currentUser: any): Promise<Job> => {   return prisma.job.create({     data: {       ...jobBody,       recruiterId: currentUser.id     }   }); };  const queryJobs = async <Key extends keyof Job>(   filter: object,   userRole: Role,   options: {     limit?: number;     page?: number;     sortBy?: string;     sortType?: 'asc' | 'desc';   },   keys: Key[] = [     'id',     'title',     'description',     'location',     'employmentType',     'isClosed',     'deadline',     'createdAt',     'updatedAt'   ] as Key[] ): Promise<Pick<Job, Key>[]> => {   const page = options.page ?? 1;   const limit = options.limit ?? 10;   const sortBy = options.sortBy;   const sortType = options.sortType ?? 'desc';   if(userRole === Role.CANDIDATE){     filter = {...filter, isClosed: false,  deadline: {       gt: new Date() // Filter for jobs with deadline greater than current date     }};   }   const jobs = await prisma.job.findMany({     where: {       ...filter                  },     select: keys.reduce((obj, k) => ({ ...obj, [k]: true }), {}),     skip: (page - 1) * limit,     take: limit,     orderBy: sortBy ? { [sortBy]: sortType } : undefined   });   return jobs as Pick<Job, Key>[]; };  const getJobById = async <Key extends keyof Job>(   id: number,   keys: Key[] = [     'id',     'title',     'description',     'location',     'employmentType',     'deadline',     'createdAt',     'updatedAt'   ] as Key[] ): Promise<Pick<Job, Key> | null> => {   return prisma.job.findUnique({     where: { id },     select: keys.reduce((obj, k) => ({ ...obj, [k]: true }), {})   }) as Promise<Pick<Job, Key> | null>; };  const updateJobById = async <Key extends keyof Job>(   jobId: number,   updateBody: any,   currentUser: any,   keys: Key[] = [     'id',     'title',     'description',     'location',     'isClosed',     'employmentType',     'deadline',     'updatedAt'   ] as Key[] ): Promise<Pick<Job, Key> | null> => {   const job = await getJobById(jobId, ['id', 'recruiterId']);   if (!job) {     throw new ApiError(httpStatus.NOT_FOUND, 'Job not found');   }   if (job.recruiterId !== currentUser.id) {     throw new ApiError(httpStatus.FORBIDDEN, 'You are not authorized to update this job');   }   const updatedJob = await prisma.job.update({     where: { id: job.id },     data: updateBody,     select: keys.reduce((obj, k) => ({ ...obj, [k]: true }), {})   });   return updatedJob as Pick<Job, Key> | null; };  export default {   createJob,   queryJobs,   getJobById,   updateJobById }; ', ''